\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
Based on the experiments it can be said, that the framework works fine and it can be successfully used to speed up computation in the local network. Although the achieved speed up does not grow linearly with the increasing number of nodes, it can be quite significant. It was not tested in WAN environments, however, according to the results, the transfers of the data takes indispensable portion of the whole processing time, so the improvement depends on the network throughput. 

As is being discussed in \hyperref[Problems-alternatives-and-possible-improvements]{chapter 4}, the framework could be further improved. To achieve more effective distribution of the work, more sophisticated scheduling could be employed that would take into account network topology or each node's performance and possibly create chunks of different sizes etc. It would require some better network knowledge. Also it was showed, that some redundancy for prevention of re-computing all chunks from one particular node in the case of failure could be useful. However, this would cause worse performance and also the advantages are quite unsure. Because of the speed of the network the data transfers generally seems to be a bottleneck, so good scheduling algorithm appears to be very important, together with optimal choice of the chunk size. This leads us to an idea, that in reliable network environments it can be good idea to centralize logic to special node in order to achieve better performance and accept potential malfunctions caused by the control node failure. This control node would schedule the process for each client that would ask. Another advantage of this approach is the fact, that this node could use a knowledge of the current network state, that is, which nodes are employed and how.

Nevertheless, a lot of computer networks can suffer from unreliability and there always is a possibility of node failure. That is the reason, why our framework can be very useful, since it is able to deal with error situations and does not require any special nodes. Among video encoding, it could be easily modified to process different tasks, such as processing large data sets or images. Although the efficiency is dependent on the current conditions, mainly the network speed, the achieved speedup can be quite significant.